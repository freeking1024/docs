# 线程

## Q1:如何同时启动三个线程？

在 Java 中，如果你要启动三个线程，它们分别打印 1、2、3，并且顺序执行`（1 → 2 → 3）`，就不能直接用` Thread.start()`，因为线程是异步的，不能保证顺序。要想按**顺序**控制输出，必须使用线程间同步机制。

### 1. 使用 CountDownLatch 来控制线程执行顺序。

```java
import java.util.concurrent.CountDownLatch;

public class MultiThreadPrint {
    public static void main(String[] args) {
        CountDownLatch latch2 = new CountDownLatch(1);
        CountDownLatch latch3 = new CountDownLatch(1);
        Thread t1 = new Thread(() -> {
            System.out.println(1);
            latch2.countDown();
        }, "1");
        Thread t2 = new Thread(() -> {
            try {
                latch2.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(2);
            latch3.countDown();
        }, "2");
        Thread t3 = new Thread(() -> {
            try {
                latch3.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(3);
        }, "3");

        t3.start();
        t2.start();
        t1.start();

    }
}
```

### 2. 信号量机制 Semaphore

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        Semaphore s1 = new Semaphore(1); // 先释放 1 → t1 可先执行
        Semaphore s2 = new Semaphore(0); // t2 等待 t1 释放
        Semaphore s3 = new Semaphore(0); // t3 等待 t2 释放

        Thread t1 = new Thread(() -> {
            try {
                s1.acquire();
                System.out.println("1");
                s2.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread t2 = new Thread(() -> {
            try {
                s2.acquire();
                System.out.println("2");
                s3.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread t3 = new Thread(() -> {
            try {
                s3.acquire();
                System.out.println("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        t3.start();
        t2.start();
        t1.start();
    }
}

```

### 对比

| 特性     | `CountDownLatch`                         | `Semaphore`                                 |
| -------- | ---------------------------------------- | ------------------------------------------- |
| 控制方式 | **等待多个线程完成**                     | **控制并发线程数量 / 顺序**                 |
| 初始计数 | 固定值（如 3）                           | 可设置许可数（如 3）                        |
| 计数行为 | 只能 `countDown()` 递减                  | `acquire()` 减、`release()` 增              |
| 能否重置 | 不可重置（用完即废）                     | 可重复使用                                  |
| 用途     | 一次性等待多个线程完成后再执行某个操作   | 控制资源访问、限流、按序执行                |
| 阻塞方法 | `await()`（等待倒计数归零）              | `acquire()`（获取许可）                     |
| 唤醒方式 | `countDown()` 到 0 自动唤醒所有等待线程  | `release()` 主动释放许可，唤醒一个/多个线程 |
| 实现原理 | 基于 AQS 的 **共享模式**（等待计数归 0） | 基于 AQS 的 **共享模式**（管理许可数量）    |

## Q2:线程池(线程)的开启与关闭
1. `start()`启动
2. `execute()`和`submit()`，`execute()`无法获取返回值，`submit()`可以获取返回值。
3. `shutdown()`关闭线程池不接受新任务，队列内任务执行结束； `shutdownNow()`关闭线程池，终止正在执行的任务。

## Q3:内置线程池的缺陷有哪些？

1. `FixedThreadPool`、`SingleThreadExecutor`:容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列），队列永远不会被放满。
2. `CachedThreadPool`:`maximumPoolSize`被设置为 `Integer.MAX.VALUE`，即它是无界的，这也就意味着如果主线程提交任务的速度高于 `maximumPool` 中线程处理任务的速度时，`CachedThreadPool`会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。
3. `ScheduledThreadPoolExecutor`继承了 `ThreadPoolExecutor`，所以创建 `ScheduledThreadExecutor`本质也是创建一个 `ThreadPoolExecutor`线程池，只是传入的参数不相同。

## Q4:并发容器有哪些？
1. `ConcurrentHashMap`: 线程安全的 HashMap
2. `CopyOnWriteArrayList`: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。
3. `ConcurrentLinkedQueue`: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
4. `BlockingQueue` : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
5. `ConcurrentSkipListMap` : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

