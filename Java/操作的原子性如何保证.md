## 原子性如何保证？volatile可以吗？如果不可以，哪些手段可以保证呢？
> `inc++` 其实是一个复合操作，包括三步：
>1. 读取 inc 的值。
>2. 对 inc 加 1。
>3. 将 inc 的值写回内存。
1. `sychronized`作用于方法

    ```java
    public synchronized void increase() {
        inc++;
    }
    ``````
2. `AutomticInteger`创建的Integer对象
    ```java
    public AtomicInteger inc = new AtomicInteger();

    public void increase() {
        inc.getAndIncrement();
    }
    ```

3. `ReentrantLock`对++操作加锁
    ```java
    Lock lock = new ReentrantLock();
    public void increase() {
        lock.lock();
        try {
            inc++;
        } finally {
            lock.unlock();
        }
    }
    ```


【实现】
```java
/*
* 保证原子性：
* 1. sychronized作用于方法
* 2. AutomticInteger创建的Integer对象
* 3. ReentrantLock对++操作加锁
* */
public class VolatileAtomicityDemo {
    public volatile static int inc = 0;

    public synchronized void increase() {
        inc++;
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo();
        for (int i = 0; i < 5; i++) {
            threadPool.execute(() -> {
                for (int j = 0; j < 500; j++) {
                    volatileAtomicityDemo.increase();
                }
            });
        }
        // 等待1.5秒，保证上面程序执行完成
        Thread.sleep(1500);
        System.out.println(inc);
        threadPool.shutdown();
    }
}
```
## ABA问题到底是什么？举个例子？
> ABA和数据结构、内存相关。

【例子】
链表：A->B->C->D
线程1:对A执行CAS操作，同时线程2也对A进行修改，可能出现增删改，最后还是还原了A。还原的A链接的不再是B了，而是D或者E。但是线程A的逻辑还是ABC的逻辑去处理的。仅仅判断A自身是否变化是不够的。