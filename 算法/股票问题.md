# 股票问题总结

## Leetcode题目
[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)<br/>
[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)<br/>
[123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)<br/>
[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)<br/>
[3573. 买卖股票的最佳时机 V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/)<br/>
[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)<br/>
[309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

## 买卖股票的最佳时机
> 股票只能买卖一次，求最大利润

【贪心】<br/>
取左侧最小，右侧最大.
```java
    public int maxProfit(int[] prices){
        int low = Integer.MIN_VALUE;
        int ressult = 0;
        for(int i = 0;i<prices.lenght;i++>){
            low = Math.min(low,prices[i]);
            result = Math.max(result,prices[i] - low);
        }
        return result;
    }

```

【动态规划】<br/>
1. 第i天持有股票
    - 第i-1天就持有股票，那么就保持现状 `dp[i - 1][0]`
    - 第i天买入股票，所得现金就是买入今天的股票后所得现金`-prices[i]` 所以`dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);`
2. 第i天不持有股票
    - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金`dp[i - 1][1]`
    - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]` 所以`dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`

## 买卖股票的最佳时机II
> 可以多次买卖股票，问最大收益。

【贪心】<br/>
收集每天的正利润即可。
```java
    public int maxProfit(int[] prices){
        int result = 0;
        for(int i = 1;i<prices.length;i++>){
            result += Math.max(prices[i] - prices[i-1],0);
        }
        return result;
    }
```
【动态规划】<br/>
 dp[i][0] 表示第i天持有股票所得现金。<br/>
 dp[i][1] 表示第i天不持有股票所得最多现金
1. 第i天持有股票：
    - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
    - 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`
2. 第i天不持有股票
    - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金`dp[i - 1][1]`
    - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]` 所以`dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`
    ```java
    // 动态规划
    class Solution 
        // 实现1：二维数组存储
        // 可以将每天持有与否的情况分别用 dp[i][0] 和 dp[i][1] 来进行存储
        // 时间复杂度：O(n)，空间复杂度：O(n)
        public int maxProfit(int[] prices) {
            int n = prices.length;
            int[][] dp = new int[n][2];     // 创建二维数组存储状态
            dp[0][0] = 0;                   // 初始状态
            dp[0][1] = -prices[0];
            for (int i = 1; i < n; ++i) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    // 第 i 天，没有股票
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    // 第 i 天，持有股票
            }
            return dp[n - 1][0];    // 卖出股票收益高于持有股票收益，因此取[0]
        }
    }
    ```

## 买卖股票的最佳时机III
> 最多买卖两次，问最大收益。

【动态规划】
```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // 边界判断, 题目中 length >= 1, 所以可省去
        if (prices.length == 0) return 0;

        /*
         * 定义 5 种状态:
         * 0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出
         */
        int[][] dp = new int[len][5];
        dp[0][1] = -prices[0];
        // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润
        dp[0][3] = -prices[0];

        for (int i = 1; i < len; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }

        return dp[len - 1][4];
    }
}

```
## 买卖股票的最佳时机IV
> 最多买卖k笔交易，问最大收益。

【动态规划】
```java
// 版本一: 三维 dp数组
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length == 0) return 0;

        // [天数][交易次数][是否持有股票]
        int len = prices.length;
        int[][][] dp = new int[len][k + 1][2];
        
        // dp数组初始化
        // 初始化所有的交易次数是为确保 最后结果是最多 k 次买卖的最大利润
        for (int i = 0; i <= k; i++) {
            dp[0][i][1] = -prices[0];
        }

        for (int i = 1; i < len; i++) {
            for (int j = 1; j <= k; j++) {
                // dp方程, 0表示不持有/卖出, 1表示持有/买入
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        return dp[len - 1][k][0];
    }
}

// 版本二: 二维 dp数组
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length == 0) return 0;

        // [天数][股票状态]
        // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作
        int len = prices.length;
        int[][] dp = new int[len][k*2 + 1];
        
        // dp数组的初始化, 与版本一同理
        for (int i = 1; i < k*2; i += 2) {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < len; i++) {
            for (int j = 0; j < k*2 - 1; j += 2) {
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[len - 1][k*2];
    }
}
```

## 买卖股票的最佳时机V
> 普通交易：先买后卖，做空交易：先卖后买

【动态规划】
1. 状态
    - **f[i][j][s]**​ 表示：
    - ​**i**​：前 i 天（0 ≤ i ≤ n）。 ​
    - **j**​：已经进行了 j 次交易（1 ≤ j ≤ k + 1）。
    - ​**s**​：当前状态（0, 1, 2）：
        - ​**s = 0​：​不持有股票**​（可以买入或休息）。
        - ​**s = 1​：​持有股票**​（可以卖出或休息）。
        - **s = 2​：​刚卖出股票**​（可以买回或休息）。

```java
class Solution {
    public long maximumProfit(int[] prices, int k) {
        int n = prices.length;
        long[][][] f = new long[n + 1][k + 2][3];
        for (long[][] mat : f) {
            for (long[] row : mat) {
                Arrays.fill(row, Long.MIN_VALUE / 2);
            }
        }
        for (int j = 1; j <= k + 1; j++) {
            f[0][j][0] = 0;
        }
        for (int i = 0; i < n; i++) {
            int p = prices[i];
            for (int j = 1; j <= k+1; j++) {
                /*
                1.前一天不持有股票​（f[i][j][0]）。
                2.​前一天持有股票，今天卖出​（f[i][j][1] + p，普通交易）。
                3.​前一天刚卖出股票，今天买回​（f[i][j][2] - p，做空交易）。*/
                f[i + 1][j][0] = Math.max(f[i][j][0], Math.max(f[i][j][1] + p, f[i][j][2] - p));

                /*
                1.​前一天持有股票​（f[i][j][1]）。
                2.​前一天不持有股票，今天买入​（f[i][j - 1][0] - p，消耗一次交易）。
                */
                f[i + 1][j][1] = Math.max(f[i][j][1], f[i][j - 1][0] - p);
                /*
                1.前一天刚卖出股票​（f[i][j][2]）。
                2.​前一天不持有股票，今天卖出​（f[i][j - 1][0] + p，消耗一次交易）。
                */
                f[i + 1][j][2] = Math.max(f[i][j][2], f[i][j - 1][0] + p);
            }
        }
        return f[n][k + 1][0];
    }
}
```
## 买卖股票的最佳时机含手续费
> 可以多次买卖，但每次有手续费。

【动态规划】
```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[prices.length - 1][0];
    }
}
```


## 买卖股票的最佳时机含冷冻期
> 可以多次买卖但每次卖出有冷冻期1天。

【动态规划】
```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
//        0: 持有股票状态 1:保持卖出 2:卖出 3:冷冻
        int[][] dp = new int[n][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(dp[n - 1][1], Math.max(dp[n - 1][2], dp[n - 1][3]));
    }
}
```