# 操作系统基本知识

## Q1: 操作系统是做什么的？

1. 目的：管理计算机**软硬件资源**
2. 层级：位于应用层和硬件系统之间
3. 功能：
   - 进程和线程的管理
   - 内存管理
   - 文件管理
   - 设备管理
   - 网络管理
   - 安全管理

## Q2: 用户态、内核态是什么？

1. 用户态（目态）：用户程序运行的状态
2. 内核态（管态）：操作系统核心程序运行的状态
3. 为什么要区分两种状态？
   - 保证安全性
   - 保证隔离性
4. 怎么切换到内核态呢？
   - 系统调用：使用 OS 对外暴露的中断来实现读取磁盘资源
   - 中断：外部设备发送信号给 CPU，CPU 暂停当前程序，转而去处理中断程序
   - 异常：程序运行时遇到错误，CPU 暂停当前程序，转而去处理异常程序
5. 中断又是什么呢？
   - CPU 执行时，由于外部事件或内部事件的发生，暂停执行当前程序，转去处理该事件，处理完成后恢复原程序的过程。
   - 切换是怎么实现的？
     - 保存现场：程序计数器（PC）、进程控制块（PCB）
     - 识别中断源：中断向量表
     - 执行中断程序：跳转到对应的中断处理程序
     - 恢复现场：从 PCB 恢复之前的状态
6. 异常又是什么呢？
   - 程序运行时遇到错误，CPU 暂停当前程序，转而去处理异常程序
7. 怎么区分中断和异常呢？<br/>
   | 特性 | 中断|异常|
   |------|-------|----|
   |触发方式 |外部硬件 |CPU 执行指令内部发生的错误|
   | 例子 |键盘输入、磁盘 I/O、定时器到期 |除 0、非法内存访问|

## Q3: 进程和线程的区别？

表格汇总：

| **特性**       | **进程（Process）**                                       | **线程（Thread）**                                   |
| -------------- | --------------------------------------------------------- | ---------------------------------------------------- |
| **定义**       | 进程是程序的一次执行，是系统资源分配的最小单位。          | 线程是进程中的一个执行单元，是 CPU 调度的基本单位。  |
| **内存空间**   | 每个进程拥有独立的内存空间。                              | 线程共享同一进程的内存空间。                         |
| **资源占用**   | 进程之间相互独立，拥有各自的资源（内存、文件描述符等）。  | 线程之间共享资源，因此占用的资源较少。               |
| **创建开销**   | 进程的创建需要操作系统分配资源，开销较大。                | 线程的创建开销小，因为它们共享进程资源。             |
| **通信方式**   | 进程之间的通信（IPC）通常通过管道、消息队列、共享内存等。 | 线程之间通过共享内存直接通信，速度较快。             |
| **调度与切换** | 进程调度和切换需要较高的开销，涉及到完整的上下文切换。    | 线程调度和切换开销较小，因为它们共享进程的内存空间。 |
| **执行独立性** | 进程具有较强的独立性，崩溃一个进程不会影响其他进程。      | 线程间是相互依赖的，一个线程崩溃可能影响整个进程。   |
| **并发性**     | 支持并发执行，但进程间的通信和同步较复杂。                | 线程更适合并发执行，同一进程内的线程之间同步较简单。 |
| **上下文切换** | 进程切换时需要保存和加载较多的上下文信息，效率较低。      | 线程切换时上下文信息较少，切换效率高。               |
| **适用场景**   | 适合处理需要完全独立的任务或需要较高隔离的场景。          | 适合处理需要并发执行且资源共享的任务。               |
| **崩溃影响**   | 进程崩溃不会影响其他进程。                                | 线程崩溃可能导致整个进程的崩溃。                     |

### 主要区别总结：

- **内存和资源**：进程是独立的资源单位，拥有独立的内存空间；而线程是进程的子单元，共享进程的内存空间。
- **开销**：进程的创建和切换开销较大，线程由于共享内存，因此开销较小。
- **并发性**：线程间通信效率更高，但更容易发生同步问题；进程之间更独立，但通信较复杂。
  `进程适用于需要强隔离的场景，线程则适用于需要高效并发的场景。`

## Q4：线程之间如何通信呢？

1. 线程间通信：

   - 互斥锁：Java 中的 `synchronized`、`Lock`
   - 读写锁：`ReadWriteLock`
   - 信号量：`Semaphore`
   - 屏障：`CyclicBarrier`
   - 事件：Object 类的方法`wait()` 和 `notify()` / `notifyAll()`
   - 线程安全的集合：

   ```java
   public static void main(String[] args) {
        // 创建一个普通的 ArrayList
        List<String> list = new ArrayList<>();

        // 使用 Collections.synchronizedList 包装成线程安全的 List
        List<String> synchronizedList = Collections.synchronizedList(list);

        // 创建一个普通的 HashMap
        Map<String, Integer> map = new HashMap<>();

        // 使用 Collections.synchronizedMap 包装成线程安全的 Map
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(map);

        // 创建一个普通的 HashSet
        Set<String> set = new HashSet<>();

        // 使用 Collections.synchronizedSet 包装成线程安全的 Set
        Set<String> synchronizedSet = Collections.synchronizedSet(set);
    }
   ```

   > ❗️ 注意 ​：虽然这些集合通过 Collections.synchronizedXXX() 变成了线程安全，但在复合操作 ​（如“检查再执行”——check-then-act）时，仍然需要手动进行同步。例如：
   >
   > ```java
   > synchronized (synchronizedList) {
   >    if (!synchronizedList.contains("item")) {
   >        synchronizedList.add("item");
   >    }
   > }
   > ```
   >
   > | 集合类型    | 线程安全实现类        | 特点                                                                     |
   > | ----------- | --------------------- | ------------------------------------------------------------------------ |
   > | List        | CopyOnWriteArrayList  | 写时复制（Copy-On-Write）机制，适合读多写少的场景，写操作开销较大        |
   > | Set         | CopyOnWriteArraySet   | 基于 CopyOnWriteArrayList 实现的线程安全 Set                             |
   > | Map         | ConcurrentHashMap     | 高并发优化的哈希表，分段锁机制（Java 7）或 CAS + synchronized（Java 8+） |
   > | Queue/Deque | ConcurrentLinkedQueue | 无界非阻塞队列，基于 CAS 实现，适合高并发场景                            |
   > |             | ArrayBlockingQueue    | 有界阻塞队列，基于锁实现，适合生产者-消费者模型                          |
   > |             | LinkedBlockingQueue   | 无界阻塞队列，基于链表实现，适合高并发场景                               |
   > |             | PriorityBlockingQueue | 优先级阻塞队列，基于堆实现，元素有序                                     |
   > |             | DelayQueue            | 延迟队列，基于优先级队列实现，元素延迟到期后才能被消费                   |

## Q5：进程间是怎么通信的呢？

> 进程间通信（IPC）是指在不同进程之间交换信息的机制。

[进程之间的通信（IPC）](https://www.jianshu.com/p/c1015f5ffa74)

## Q:死锁怎么产生的？如何解决呢？
