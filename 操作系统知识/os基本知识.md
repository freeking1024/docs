# 操作系统基本知识

## Q1: 操作系统是做什么的？

1. 目的：管理计算机**软硬件资源**
2. 层级：位于应用层和硬件系统之间
3. 功能：
   - 进程和线程的管理
   - 内存管理
   - 文件管理
   - 设备管理
   - 网络管理
   - 安全管理

## Q2: 用户态、内核态是什么？

1. 用户态（目态）：用户程序运行的状态
2. 内核态（管态）：操作系统核心程序运行的状态
3. 为什么要区分两种状态？
   - 保证安全性
   - 保证隔离性
4. 怎么切换到内核态呢？
   - 系统调用：使用 OS 对外暴露的中断来实现读取磁盘资源
   - 中断：外部设备发送信号给 CPU，CPU 暂停当前程序，转而去处理中断程序
   - 异常：程序运行时遇到错误，CPU 暂停当前程序，转而去处理异常程序
5. 中断又是什么呢？
   - CPU 执行时，由于外部事件或内部事件的发生，暂停执行当前程序，转去处理该事件，处理完成后恢复原程序的过程。
   - 切换是怎么实现的？
     - 保存现场：程序计数器（PC）、进程控制块（PCB）
     - 识别中断源：中断向量表
     - 执行中断程序：跳转到对应的中断处理程序
     - 恢复现场：从 PCB 恢复之前的状态
6. 异常又是什么呢？
   - 程序运行时遇到错误，CPU 暂停当前程序，转而去处理异常程序
7. 怎么区分中断和异常呢？<br/>
   | 特性 | 中断|异常|
   |------|-------|----|
   |触发方式 |外部硬件 |CPU 执行指令内部发生的错误|
   | 例子 |键盘输入、磁盘 I/O、定时器到期 |除 0、非法内存访问|

## Q3: 进程和线程的区别？

表格汇总：

| **特性**       | **进程（Process）**                                       | **线程（Thread）**                                   |
| -------------- | --------------------------------------------------------- | ---------------------------------------------------- |
| **定义**       | 进程是程序的一次执行，是系统资源分配的最小单位。          | 线程是进程中的一个执行单元，是 CPU 调度的基本单位。  |
| **内存空间**   | 每个进程拥有独立的内存空间。                              | 线程共享同一进程的内存空间。                         |
| **资源占用**   | 进程之间相互独立，拥有各自的资源（内存、文件描述符等）。  | 线程之间共享资源，因此占用的资源较少。               |
| **创建开销**   | 进程的创建需要操作系统分配资源，开销较大。                | 线程的创建开销小，因为它们共享进程资源。             |
| **通信方式**   | 进程之间的通信（IPC）通常通过管道、消息队列、共享内存等。 | 线程之间通过共享内存直接通信，速度较快。             |
| **调度与切换** | 进程调度和切换需要较高的开销，涉及到完整的上下文切换。    | 线程调度和切换开销较小，因为它们共享进程的内存空间。 |
| **执行独立性** | 进程具有较强的独立性，崩溃一个进程不会影响其他进程。      | 线程间是相互依赖的，一个线程崩溃可能影响整个进程。   |
| **并发性**     | 支持并发执行，但进程间的通信和同步较复杂。                | 线程更适合并发执行，同一进程内的线程之间同步较简单。 |
| **上下文切换** | 进程切换时需要保存和加载较多的上下文信息，效率较低。      | 线程切换时上下文信息较少，切换效率高。               |
| **适用场景**   | 适合处理需要完全独立的任务或需要较高隔离的场景。          | 适合处理需要并发执行且资源共享的任务。               |
| **崩溃影响**   | 进程崩溃不会影响其他进程。                                | 线程崩溃可能导致整个进程的崩溃。                     |

### 主要区别总结：

- **内存和资源**：进程是独立的资源单位，拥有独立的内存空间；而线程是进程的子单元，共享进程的内存空间。
- **开销**：进程的创建和切换开销较大，线程由于共享内存，因此开销较小。
- **并发性**：线程间通信效率更高，但更容易发生同步问题；进程之间更独立，但通信较复杂。
  `进程适用于需要强隔离的场景，线程则适用于需要高效并发的场景。`

## Q4：线程之间如何通信呢？

1. 线程间通信：

   - 互斥锁：Java 中的 `synchronized`、`Lock`
   - 读写锁：`ReadWriteLock`
   - 信号量：`Semaphore`
   - 屏障：`CyclicBarrier`
   - 事件：Object 类的方法`wait()` 和 `notify()` / `notifyAll()`
   - 线程安全的集合：

   ```java
   public static void main(String[] args) {
        // 创建一个普通的 ArrayList
        List<String> list = new ArrayList<>();

        // 使用 Collections.synchronizedList 包装成线程安全的 List
        List<String> synchronizedList = Collections.synchronizedList(list);

        // 创建一个普通的 HashMap
        Map<String, Integer> map = new HashMap<>();

        // 使用 Collections.synchronizedMap 包装成线程安全的 Map
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(map);

        // 创建一个普通的 HashSet
        Set<String> set = new HashSet<>();

        // 使用 Collections.synchronizedSet 包装成线程安全的 Set
        Set<String> synchronizedSet = Collections.synchronizedSet(set);
    }
   ```

   > ❗️ 注意 ​：虽然这些集合通过 Collections.synchronizedXXX() 变成了线程安全，但在复合操作 ​（如“检查再执行”——check-then-act）时，仍然需要手动进行同步。例如：
   >
   > ```java
   > synchronized (synchronizedList) {
   >    if (!synchronizedList.contains("item")) {
   >        synchronizedList.add("item");
   >    }
   > }
   > ```
   >
   > | 集合类型    | 线程安全实现类        | 特点                                                                     |
   > | ----------- | --------------------- | ------------------------------------------------------------------------ |
   > | List        | CopyOnWriteArrayList  | 写时复制（Copy-On-Write）机制，适合读多写少的场景，写操作开销较大        |
   > | Set         | CopyOnWriteArraySet   | 基于 CopyOnWriteArrayList 实现的线程安全 Set                             |
   > | Map         | ConcurrentHashMap     | 高并发优化的哈希表，分段锁机制（Java 7）或 CAS + synchronized（Java 8+） |
   > | Queue/Deque | ConcurrentLinkedQueue | 无界非阻塞队列，基于 CAS 实现，适合高并发场景                            |
   > |             | ArrayBlockingQueue    | 有界阻塞队列，基于锁实现，适合生产者-消费者模型                          |
   > |             | LinkedBlockingQueue   | 无界阻塞队列，基于链表实现，适合高并发场景                               |
   > |             | PriorityBlockingQueue | 优先级阻塞队列，基于堆实现，元素有序                                     |
   > |             | DelayQueue            | 延迟队列，基于优先级队列实现，元素延迟到期后才能被消费                   |

## Q5：进程间是怎么通信的呢？

> 进程间通信（IPC）是指在不同进程之间交换信息的机制。

[进程之间的通信（IPC）](https://www.jianshu.com/p/c1015f5ffa74)<br/>
[管道的模拟实现-C 语言](http://blog.chinaunix.net/uid-26833883-id-3227144.html)

## Q6：互斥锁和信号量有区别吗？

1. 互斥锁：为了实现多个线程对同一资源的互斥访问
2. 信号量：为了多个线程之间的同步，当信号量为二值时，就成为了互斥锁

## Q7：进程的调度算法有哪些？

> 目的：确定首先执行哪个进程、最后执行哪个进程，实现 CPU 利用率最大化。

1. 先来先服务（FCFS）
2. 短作业优先（SJF）：估计运行时间最短
3. 优先级调度：
4. 时间片轮转（RR）：每个进程分配固定的时间片，时间片用完后，CPU 切换到下一个进程。
5. 多级反馈队列

## Q8：死锁怎么产生的？如何解决呢？

> 多个进程/线程同时被阻塞，等待某个资源呢释放。被无限期阻塞，程序无法正常终止。

1. 产生的条件：
   - 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
   - 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
   - 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
   - 循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。
2. 避免死锁：
   - 一次分配全部资源再执行进程
   - 层次分配策略

## Q9：内存管理？

[内存管理](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86)

1. 页面置换算法

   - **最佳页面置换算法（OPT，Optimal）**：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。
   - **先进先出页面置换算法（FIFO，First In First Out）** : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可满足需求。不过，它的性能并不是很好。
   - **最近最久未使用页面置换算法（LRU ，Least Recently Used）**：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。
   - **最少使用页面置换算法（LFU，Least Frequently Used）** : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。
   - **时钟页面置换算法（Clock）**：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。

2. 磁盘调度算法
   - **先来先服务算法（First-ComeFirst-Served，FCFS)**：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。
   - **最短寻道时间优先算法（ShortestSeekTimeFirst，SSTF)**：也被称为最佳服务优先（Shortest ServiceTimeFirst，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。
   - **扫描算法（SCAN)：** 也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。
   - **循环扫描算法（CircularScan，C-SCAN)：** SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。
   - **边扫描边观察算法（LOOK)：** SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。
   - **均衡循环扫描算法（C-LOOK)：** C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。
